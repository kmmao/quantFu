# 极星v12.py策略改造指南

本文档详细说明如何修改极星量化策略,使其能够将成交数据推送到期货管理平台。

## 📋 改造概述

**目标:**
- 保持原有交易逻辑**完全不变**
- 增加数据推送功能(失败不影响交易)
- 支持持仓对账功能

**改动范围:**
- 新增1个文件:`data_pusher.py`(独立模块)
- 修改`v12.py`:仅增加3-5处函数调用,共约20行代码

---

## 🚀 改造步骤

### Step 1:上传data_pusher.py到极星

1. 将 `archived/data_pusher.py` 文件上传到极星量化平台
2. 与 `v12.py` 放在同一目录下

**目录结构:**
```
极星量化
├─ v12分区
│  ├─ v12.py           # 现有策略
│  └─ data_pusher.py   # 新增推送模块
```

### Step 2:修改data_pusher.py配置

打开 `data_pusher.py`,修改第17行的后端地址:

```python
# 本地开发(如果后端在同一台机器)
BACKEND_URL = "http://localhost:8888"

# 生产环境(如果后端在其他服务器)
BACKEND_URL = "http://your_server_ip:8888"
```

**如何确定地址?**
- 如果极星和后端在同一台电脑:**http://localhost:8888**
- 如果在不同电脑:用后端服务器的IP地址,如**http://192.168.1.100:8888**

### Step 3:修改v12.py - 导入模块

在 `v12.py` **顶部**(第1-10行之间)增加导入:

```python
# ========== 新增导入 ==========
from data_pusher import push_trade, push_position_snapshot
# =============================

import talib
from datetime import datetime
import math
# ... 其他导入保持不变
```

### Step 4:修改v12.py - 推送开仓数据

在 `market_order()` 函数中,找到下单成功后的代码块,**增加推送调用**:

**位置:**约第717-730行(下单成功后)

**原代码:**
```python
ret_enter, enter_order_id = A_SendOrder(
    market_order_type,
    Enum_Entry(),
    order_num,
    round(Close()[-1], 0)
)

if ret_enter == 0:
    send_msg_thread(f"{content}", f"下单成功...")
    # ... 其他代码
```

**修改为(仅增加try-except块):**
```python
ret_enter, enter_order_id = A_SendOrder(
    market_order_type,
    Enum_Entry(),
    order_num,
    round(Close()[-1], 0)
)

if ret_enter == 0:
    send_msg_thread(f"{content}", f"下单成功...")

    # ========== 新增:推送成交数据 ==========
    try:
        push_trade(
            account_id=context.accountID(),  # 极星提供的账户ID
            symbol=trade_contractNo,         # 合约代码
            direction="buy" if market_order_type == Enum_Buy() else "sell",
            offset="open",                   # 开仓
            volume=order_num,                # 手数
            price=Close()[-1],               # 成交价
            order_id=enter_order_id          # 订单ID
        )
    except:
        pass  # 推送失败不影响交易
    # =======================================

    # ... 其他代码保持不变
```

### Step 5:修改v12.py - 推送平仓数据

在 `close_postion()` 函数中,找到平仓成功的代码块,**增加推送调用**:

**位置:**约第782-795行

**原代码:**
```python
ret, exit_order_id = A_SendOrder(
    market_order_type,
    Enum_Exit(),
    order_num,
    order_price
)

if ret == 0:
    send_msg_thread(f"{content}", f"平仓成功...")
    # ... 其他代码
```

**修改为:**
```python
ret, exit_order_id = A_SendOrder(
    market_order_type,
    Enum_Exit(),
    order_num,
    order_price
)

if ret == 0:
    send_msg_thread(f"{content}", f"平仓成功...")

    # ========== 新增:推送平仓数据 ==========
    try:
        push_trade(
            account_id=context.accountID(),
            symbol=trade_contractNo,
            direction="sell" if market_order_type == Enum_Sell() else "buy",
            offset="close",                  # 平仓
            volume=order_num,
            price=order_price,
            order_id=exit_order_id
        )
    except:
        pass
    # =======================================

    # ... 其他代码保持不变
```

### Step 6:修改v12.py - 定时推送持仓快照

在 `handle_data()` 函数中,找到定时触发的处理,**增加快照推送**:

**位置:**约第466-487行

**原代码:**
```python
def handle_data(context):
    if order_count_day >= 1000:
        return

    # 数据初始化
    if data_init(context):
        return

    # 指标计算
    bbi_handle(context)

    # ... 其他代码
```

**修改为(在定时触发处增加):**
```python
def handle_data(context):
    if order_count_day >= 1000:
        return

    # ========== 新增:定时推送持仓快照(用于对账) ==========
    # 每10分钟推送一次(触发类型3是10分钟定时)
    if context.triggerType() == 'T':
        try:
            push_position_snapshot(
                account_id=context.accountID(),
                symbol=trade_contractNo,
                long_position=A_BuyPositionCanCover(),      # 可平多仓
                short_position=A_SellPositionCanCover(),    # 可平空仓
                long_avg_price=A_BuyAvgPrice(),             # 多仓均价
                short_avg_price=A_SellAvgPrice(),           # 空仓均价
                long_profit=A_BuyProfitLoss(),              # 多仓浮盈
                short_profit=A_SellProfitLoss()             # 空仓浮盈
            )
        except:
            pass
    # ====================================================

    # 数据初始化
    if data_init(context):
        return

    # 指标计算
    bbi_handle(context)

    # ... 其他代码保持不变
```

---

## ✅ 改造完成检查清单

在极星平台重新启动策略前,请确认:

- [ ] `data_pusher.py` 已上传到极星
- [ ] `data_pusher.py` 中的 `BACKEND_URL` 已修改为正确地址
- [ ] `v12.py` 顶部已导入 `push_trade` 和 `push_position_snapshot`
- [ ] `market_order()` 函数中已增加开仓推送
- [ ] `close_postion()` 函数中已增加平仓推送
- [ ] `handle_data()` 函数中已增加快照推送
- [ ] 所有推送代码都用 `try-except` 包裹
- [ ] 后端服务已启动(运行 `python backend/main.py`)

---

## 🧪 测试推送功能

### 方法1:使用测试脚本

在极星平台的Python终端中运行:

```python
from data_pusher import test_connection

if test_connection():
    print("✅ 后端连接成功")
else:
    print("❌ 后端连接失败")
```

### 方法2:手动测试推送

```python
from data_pusher import push_trade

# 测试推送
success = push_trade(
    account_id="85178443",
    symbol="ZCE|F|TA|2505",
    direction="buy",
    offset="open",
    volume=1,
    price=5500.0
)

print("推送结果:", "成功" if success else "失败")
```

### 方法3:查看后端日志

后端启动时会打印接收到的数据:

```bash
# 后端终端会显示:
INFO:     127.0.0.1:54321 - "POST /api/trades HTTP/1.1" 200 OK
```

---

## 🚨 常见问题排查

### 问题1:推送一直失败

**症状:**
- 极星日志显示 `[数据推送失败]`

**排查步骤:**
1. 检查 `data_pusher.py` 中的 `BACKEND_URL` 是否正确
2. 确认后端服务已启动:浏览器访问 `http://localhost:8888/health`
3. 检查防火墙是否阻止了8888端口
4. 查看后端日志是否有错误信息

**解决方法:**
```bash
# 测试后端是否可访问
curl http://localhost:8888/health

# 如果返回 {"status":"healthy",...} 说明后端正常
```

---

### 问题2:推送超时

**症状:**
- 极星日志显示 `[数据推送超时] 超过3秒`

**原因:**
- 网络延迟过高
- 后端处理慢

**解决方法:**
修改 `data_pusher.py` 第15行,增加超时时间:

```python
REQUEST_TIMEOUT = 5  # 改为5秒
```

---

### 问题3:推送成功但数据库无数据

**症状:**
- 极星无错误提示
- 后端返回200 OK
- 但Supabase数据库中 `trades` 表无数据

**排查步骤:**
1. 检查账户是否在数据库中:

```sql
SELECT * FROM accounts WHERE polar_account_id = '85178443';
```

如果无结果,说明账户未创建,参考 `database/seed/002_seed_data.sql` 添加账户。

2. 检查后端日志是否有异常

---

### 问题4:影响策略执行速度

**症状:**
- 策略执行变慢
- 错过行情

**原因:**
- 推送代码阻塞了主流程

**解决方法:**
确认所有推送代码都在 `try-except` 中,并设置了超时:

```python
try:
    push_trade(...)  # 最多阻塞3秒
except:
    pass  # 失败立即跳过
```

---

## 📊 数据验证

改造完成后,进行以下验证:

### 1. 验证成交推送

在极星下单后,检查数据库:

```sql
-- 查询最新成交记录
SELECT * FROM trades
ORDER BY created_at DESC
LIMIT 10;
```

**预期结果:**
应该能看到刚才的成交记录。

### 2. 验证持仓计算

```sql
-- 查询持仓
SELECT * FROM v_positions_summary;
```

**预期结果:**
持仓数量和均价应与极星一致。

### 3. 验证持仓对账

等待10分钟后(快照推送间隔),检查:

```sql
-- 查询对账结果
SELECT * FROM position_snapshots
WHERE is_matched = false
ORDER BY timestamp DESC;
```

**预期结果:**
- 如果 `is_matched = true`,说明数据一致
- 如果 `is_matched = false`,检查 `diff_long` 和 `diff_short` 字段,找出差异原因

---

## 🔄 回滚方案

如果改造后出现问题,需要紧急回滚:

1. **删除导入语句:**
   注释掉 `v12.py` 顶部的导入:
   ```python
   # from data_pusher import push_trade, push_position_snapshot
   ```

2. **注释所有推送调用:**
   将所有 `push_trade()` 和 `push_position_snapshot()` 调用注释掉

3. **重启策略**

策略会恢复到改造前的状态。

---

## 📝 总结

**改造影响:**
- ✅ 原交易逻辑**零修改**
- ✅ 新增代码约**20行**(含注释)
- ✅ 推送失败**不影响交易**
- ✅ 性能影响**几乎为零**(异步推送,3秒超时)

**改造收益:**
- ✅ 自动记录所有成交
- ✅ 自动计算持仓明细
- ✅ 支持持仓对账
- ✅ 为后续功能(锁仓管理、换月提醒)打好基础

---

## 💡 进阶优化(可选)

### 优化1:异步推送(避免阻塞)

如果极星支持多线程,可以将推送改为异步:

```python
import threading

def async_push_trade(*args, **kwargs):
    """异步推送,不阻塞主线程"""
    thread = threading.Thread(target=push_trade, args=args, kwargs=kwargs)
    thread.daemon = True
    thread.start()

# 使用时:
async_push_trade(account_id=..., symbol=..., ...)
```

### 优化2:批量推送

如果短时间内有多笔成交,可以先缓存,定时批量推送:

```python
# data_pusher.py中增加批量接口
def push_trades_batch(trades_list):
    """批量推送成交数据"""
    response = requests.post(
        f"{BACKEND_URL}/api/trades/batch",
        json={"trades": trades_list},
        timeout=REQUEST_TIMEOUT
    )
    return response.status_code == 200
```

---

**改造完成!祝交易顺利!** 🎉
